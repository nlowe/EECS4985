#include "stdafx.h"
#include "AESValidationTests.h"
#include "../libcrypto/AES/AES.h"
#include <iostream>
#include <iomanip>

namespace ValidationTests
{
	namespace aes
	{
		void printBlockToCERR(uint8_t* buff)
		{
			for(auto i = 0; i < 16; i++)
			{
				std::cerr << std::setfill('0') << std::setw(2) << std::hex << std::uppercase << (static_cast<int>(buff[i]) & 0xFF);
			}
		}

		bool blockEquals(uint8_t* src, uint8_t* dst, size_t len)
		{
			for(auto i = 0; i < len; i++)
			{
				if (src[i] != dst[i]) return false;
			}

			return true;
		}

		int ECBGFSBox128Encrypt()
		{
			std::cout << "\tTesting GFSBox Encryption in ECB Mode with 128-bit keys" << std::endl;

			uint8_t plaintext[7][16] = {
				{0xf3, 0x44, 0x81, 0xec, 0x3c, 0xc6, 0x27, 0xba, 0xcd, 0x5d, 0xc3, 0xfb, 0x08, 0xf2, 0x73, 0xe6},
				{0x97, 0x98, 0xc4, 0x64, 0x0b, 0xad, 0x75, 0xc7, 0xc3, 0x22, 0x7d, 0xb9, 0x10, 0x17, 0x4e, 0x72},
				{0x96, 0xab, 0x5c, 0x2f, 0xf6, 0x12, 0xd9, 0xdf, 0xaa, 0xe8, 0xc3, 0x1f, 0x30, 0xc4, 0x21, 0x68},
				{0x6a, 0x11, 0x8a, 0x87, 0x45, 0x19, 0xe6, 0x4e, 0x99, 0x63, 0x79, 0x8a, 0x50, 0x3f, 0x1d, 0x35},
				{0xcb, 0x9f, 0xce, 0xec, 0x81, 0x28, 0x6c, 0xa3, 0xe9, 0x89, 0xbd, 0x97, 0x9b, 0x0c, 0xb2, 0x84},
				{0xb2, 0x6a, 0xeb, 0x18, 0x74, 0xe4, 0x7c, 0xa8, 0x35, 0x8f, 0xf2, 0x23, 0x78, 0xf0, 0x91, 0x44},
				{0x58, 0xc8, 0xe0, 0x0b, 0x26, 0x31, 0x68, 0x6d, 0x54, 0xea, 0xb8, 0x4b, 0x91, 0xf0, 0xac, 0xa1}
			};

			uint8_t ciphertext[7][16] = {
				{0x03, 0x36, 0x76, 0x3e, 0x96, 0x6d, 0x92, 0x59, 0x5a, 0x56, 0x7c, 0xc9, 0xce, 0x53, 0x7f, 0x5e},
				{0xa9, 0xa1, 0x63, 0x1b, 0xf4, 0x99, 0x69, 0x54, 0xeb, 0xc0, 0x93, 0x95, 0x7b, 0x23, 0x45, 0x89},
				{0xff, 0x4f, 0x83, 0x91, 0xa6, 0xa4, 0x0c, 0xa5, 0xb2, 0x5d, 0x23, 0xbe, 0xdd, 0x44, 0xa5, 0x97},
				{0xdc, 0x43, 0xbe, 0x40, 0xbe, 0x0e, 0x53, 0x71, 0x2f, 0x7e, 0x2b, 0xf5, 0xca, 0x70, 0x72, 0x09},
				{0x92, 0xbe, 0xed, 0xab, 0x18, 0x95, 0xa9, 0x4f, 0xaa, 0x69, 0xb6, 0x32, 0xe5, 0xcc, 0x47, 0xce},
				{0x45, 0x92, 0x64, 0xf4, 0x79, 0x8f, 0x6a, 0x78, 0xba, 0xcb, 0x89, 0xc1, 0x5e, 0xd3, 0xd6, 0x01},
				{0x08, 0xa4, 0xe2, 0xef, 0xec, 0x8a, 0x8e, 0x33, 0x12, 0xca, 0x74, 0x60, 0xb9, 0x04, 0x0b, 0xbf}
			};

			char rawKey[16] = { 0 };

			auto key = libcrypto::aes::make_block(rawKey, 0);

			auto failures = 0;
			for(auto i = 0; i < 7; i++)
			{
				auto result = libcrypto::aes::Encrypt(reinterpret_cast<char*>(plaintext[i]), 16, key);
				if (result != 0)
				{
					std::cerr << "\t  Failure in ECB Encryption (Error code " << result << ")" << std::endl;
					failures++;
				}
				else
				{
					if(!blockEquals(ciphertext[i], plaintext[i], 16))
					{
						std::cerr << "\t  Failure in ECB Encryption (Expected: ";
						printBlockToCERR(ciphertext[i]);
						std::cerr << " but got ";
						printBlockToCERR(plaintext[i]);
						std::cerr << ")" << std::endl;
						failures++;
					}
				}
			}

			return failures;
		}

		int ECBGFSBox128Decrypt()
		{
			std::cout << "\tTesting GFSBox Decryption in ECB Mode with 128-bit keys" << std::endl;

			uint8_t ciphertext[6][16] = {
				{0x03, 0x36, 0x76, 0x3e, 0x96, 0x6d, 0x92, 0x59, 0x5a, 0x56, 0x7c, 0xc9, 0xce, 0x53, 0x7f, 0x5e},
				{0xa9, 0xa1, 0x63, 0x1b, 0xf4, 0x99, 0x69, 0x54, 0xeb, 0xc0, 0x93, 0x95, 0x7b, 0x23, 0x45, 0x89},
				{0xff, 0x4f, 0x83, 0x91, 0xa6, 0xa4, 0x0c, 0xa5, 0xb2, 0x5d, 0x23, 0xbe, 0xdd, 0x44, 0xa5, 0x97},
				{0xdc, 0x43, 0xbe, 0x40, 0xbe, 0x0e, 0x53, 0x71, 0x2f, 0x7e, 0x2b, 0xf5, 0xca, 0x70, 0x72, 0x09},
				{0x92, 0xbe, 0xed, 0xab, 0x18, 0x95, 0xa9, 0x4f, 0xaa, 0x69, 0xb6, 0x32, 0xe5, 0xcc, 0x47, 0xce},
				{0x45, 0x92, 0x64, 0xf4, 0x79, 0x8f, 0x6a, 0x78, 0xba, 0xcb, 0x89, 0xc1, 0x5e, 0xd3, 0xd6, 0x01}
			};

			uint8_t plaintext[6][16] = {
				{0xf3, 0x44, 0x81, 0xec, 0x3c, 0xc6, 0x27, 0xba, 0xcd, 0x5d, 0xc3, 0xfb, 0x08, 0xf2, 0x73, 0xe6},
				{0x97, 0x98, 0xc4, 0x64, 0x0b, 0xad, 0x75, 0xc7, 0xc3, 0x22, 0x7d, 0xb9, 0x10, 0x17, 0x4e, 0x72},
				{0x96, 0xab, 0x5c, 0x2f, 0xf6, 0x12, 0xd9, 0xdf, 0xaa, 0xe8, 0xc3, 0x1f, 0x30, 0xc4, 0x21, 0x68},
				{0x6a, 0x11, 0x8a, 0x87, 0x45, 0x19, 0xe6, 0x4e, 0x99, 0x63, 0x79, 0x8a, 0x50, 0x3f, 0x1d, 0x35},
				{0xcb, 0x9f, 0xce, 0xec, 0x81, 0x28, 0x6c, 0xa3, 0xe9, 0x89, 0xbd, 0x97, 0x9b, 0x0c, 0xb2, 0x84},
				{0xb2, 0x6a, 0xeb, 0x18, 0x74, 0xe4, 0x7c, 0xa8, 0x35, 0x8f, 0xf2, 0x23, 0x78, 0xf0, 0x91, 0x44}
			};
			
			char rawBlock[16] = { 0 };

			auto key = libcrypto::aes::make_block(rawBlock, 0);

			auto failures = 0;
			for(auto i = 0; i < 6; i++)
			{
				auto result = libcrypto::aes::Decrypt(reinterpret_cast<char*>(ciphertext[i]), 16, key);
				if (result != 0)
				{
					std::cerr << "\t  Failure in ECB Decryption (Error code " << result << ")" << std::endl;
					failures++;
				}
				else
				{
					if(!blockEquals(plaintext[i], ciphertext[i], 16))
					{
						std::cerr << "\t  Failure in ECB Decryption (Expected: ";
						printBlockToCERR(plaintext[i]);
						std::cerr << " but got ";
						printBlockToCERR(ciphertext[i]);
						std::cerr << ")" << std::endl;
						failures++;
					}
				}
			}

			return failures;
		}

		int CBCGFSBox128Encrypt()
		{
			std::cout << "\tTesting GFSBox Encryption in CBC Mode with 128-bit keys" << std::endl;

			uint8_t plaintext[7][16] = {
				{0xf3, 0x44, 0x81, 0xec, 0x3c, 0xc6, 0x27, 0xba, 0xcd, 0x5d, 0xc3, 0xfb, 0x08, 0xf2, 0x73, 0xe6},
				{0x97, 0x98, 0xc4, 0x64, 0x0b, 0xad, 0x75, 0xc7, 0xc3, 0x22, 0x7d, 0xb9, 0x10, 0x17, 0x4e, 0x72},
				{0x96, 0xab, 0x5c, 0x2f, 0xf6, 0x12, 0xd9, 0xdf, 0xaa, 0xe8, 0xc3, 0x1f, 0x30, 0xc4, 0x21, 0x68},
				{0x6a, 0x11, 0x8a, 0x87, 0x45, 0x19, 0xe6, 0x4e, 0x99, 0x63, 0x79, 0x8a, 0x50, 0x3f, 0x1d, 0x35},
				{0xcb, 0x9f, 0xce, 0xec, 0x81, 0x28, 0x6c, 0xa3, 0xe9, 0x89, 0xbd, 0x97, 0x9b, 0x0c, 0xb2, 0x84},
				{0xb2, 0x6a, 0xeb, 0x18, 0x74, 0xe4, 0x7c, 0xa8, 0x35, 0x8f, 0xf2, 0x23, 0x78, 0xf0, 0x91, 0x44},
				{0x58, 0xc8, 0xe0, 0x0b, 0x26, 0x31, 0x68, 0x6d, 0x54, 0xea, 0xb8, 0x4b, 0x91, 0xf0, 0xac, 0xa1}
			};

			uint8_t ciphertext[7][16] = {
				{0x03, 0x36, 0x76, 0x3e, 0x96, 0x6d, 0x92, 0x59, 0x5a, 0x56, 0x7c, 0xc9, 0xce, 0x53, 0x7f, 0x5e},
				{0xa9, 0xa1, 0x63, 0x1b, 0xf4, 0x99, 0x69, 0x54, 0xeb, 0xc0, 0x93, 0x95, 0x7b, 0x23, 0x45, 0x89},
				{0xff, 0x4f, 0x83, 0x91, 0xa6, 0xa4, 0x0c, 0xa5, 0xb2, 0x5d, 0x23, 0xbe, 0xdd, 0x44, 0xa5, 0x97},
				{0xdc, 0x43, 0xbe, 0x40, 0xbe, 0x0e, 0x53, 0x71, 0x2f, 0x7e, 0x2b, 0xf5, 0xca, 0x70, 0x72, 0x09},
				{0x92, 0xbe, 0xed, 0xab, 0x18, 0x95, 0xa9, 0x4f, 0xaa, 0x69, 0xb6, 0x32, 0xe5, 0xcc, 0x47, 0xce},
				{0x45, 0x92, 0x64, 0xf4, 0x79, 0x8f, 0x6a, 0x78, 0xba, 0xcb, 0x89, 0xc1, 0x5e, 0xd3, 0xd6, 0x01},
				{0x08, 0xa4, 0xe2, 0xef, 0xec, 0x8a, 0x8e, 0x33, 0x12, 0xca, 0x74, 0x60, 0xb9, 0x04, 0x0b, 0xbf}
			};

			char rawBlock[16] = { 0 };

			auto key = libcrypto::aes::make_block(rawBlock, 0);

			auto failures = 0;
			for(auto i = 0; i < 7; i++)
			{
				auto result = libcrypto::aes::Encrypt(reinterpret_cast<char*>(plaintext[i]), 16, key, key);
				if (result != 0)
				{
					std::cerr << "\t  Failure in CBC Encryption (Error code " << result << ")" << std::endl;
					failures++;
				}
				else
				{
					if(!blockEquals(ciphertext[i], plaintext[i], 16))
					{
						std::cerr << "\t  Failure in CBC Encryption (Expected: ";
						printBlockToCERR(ciphertext[i]);
						std::cerr << " but got ";
						printBlockToCERR(plaintext[i]);
						std::cerr << ")" << std::endl;
						failures++;
					}
				}
			}

			return failures;
		}

		int CBCGFSBox128Decrypt()
		{
			std::cout << "\tTesting GFSBox Decryption in CBC Mode with 128-bit keys" << std::endl;

			uint8_t ciphertext[6][16] = {
				{0x03, 0x36, 0x76, 0x3e, 0x96, 0x6d, 0x92, 0x59, 0x5a, 0x56, 0x7c, 0xc9, 0xce, 0x53, 0x7f, 0x5e},
				{0xa9, 0xa1, 0x63, 0x1b, 0xf4, 0x99, 0x69, 0x54, 0xeb, 0xc0, 0x93, 0x95, 0x7b, 0x23, 0x45, 0x89},
				{0xff, 0x4f, 0x83, 0x91, 0xa6, 0xa4, 0x0c, 0xa5, 0xb2, 0x5d, 0x23, 0xbe, 0xdd, 0x44, 0xa5, 0x97},
				{0xdc, 0x43, 0xbe, 0x40, 0xbe, 0x0e, 0x53, 0x71, 0x2f, 0x7e, 0x2b, 0xf5, 0xca, 0x70, 0x72, 0x09},
				{0x92, 0xbe, 0xed, 0xab, 0x18, 0x95, 0xa9, 0x4f, 0xaa, 0x69, 0xb6, 0x32, 0xe5, 0xcc, 0x47, 0xce},
				{0x45, 0x92, 0x64, 0xf4, 0x79, 0x8f, 0x6a, 0x78, 0xba, 0xcb, 0x89, 0xc1, 0x5e, 0xd3, 0xd6, 0x01}
			};

			uint8_t plaintext[6][16] = {
				{0xf3, 0x44, 0x81, 0xec, 0x3c, 0xc6, 0x27, 0xba, 0xcd, 0x5d, 0xc3, 0xfb, 0x08, 0xf2, 0x73, 0xe6},
				{0x97, 0x98, 0xc4, 0x64, 0x0b, 0xad, 0x75, 0xc7, 0xc3, 0x22, 0x7d, 0xb9, 0x10, 0x17, 0x4e, 0x72},
				{0x96, 0xab, 0x5c, 0x2f, 0xf6, 0x12, 0xd9, 0xdf, 0xaa, 0xe8, 0xc3, 0x1f, 0x30, 0xc4, 0x21, 0x68},
				{0x6a, 0x11, 0x8a, 0x87, 0x45, 0x19, 0xe6, 0x4e, 0x99, 0x63, 0x79, 0x8a, 0x50, 0x3f, 0x1d, 0x35},
				{0xcb, 0x9f, 0xce, 0xec, 0x81, 0x28, 0x6c, 0xa3, 0xe9, 0x89, 0xbd, 0x97, 0x9b, 0x0c, 0xb2, 0x84},
				{0xb2, 0x6a, 0xeb, 0x18, 0x74, 0xe4, 0x7c, 0xa8, 0x35, 0x8f, 0xf2, 0x23, 0x78, 0xf0, 0x91, 0x44}
			};

			char rawBlock[16] = { 0 };

			auto key = libcrypto::aes::make_block(rawBlock, 0);

			auto failures = 0;
			for(auto i = 0; i < 6; i++)
			{
				auto result = libcrypto::aes::Decrypt(reinterpret_cast<char*>(ciphertext[i]), 16, key, key);
				if (result != 0)
				{
					std::cerr << "\t  Failure in CBC Decryption (Error code " << result << ")" << std::endl;
					failures++;
				}
				else
				{
					if(!blockEquals(plaintext[i], ciphertext[i], 16))
					{
						std::cerr << "\t  Failure in CBC Decryption (Expected: ";
						printBlockToCERR(plaintext[i]);
						std::cerr << " but got ";
						printBlockToCERR(ciphertext[i]);
						std::cerr << ")" << std::endl;
						failures++;
					}
				}
			}

			return failures;
		}

		int CBCKeySBox128Encrypt()
		{
			std::cout << "\tTesting Key SBox encryption in CBC Mode with 128-bit keys" << std::endl;

			uint8_t key[20][16] = {
				{10a58869d74be5a374cf867cfb473859},
				{caea65cdbb75e9169ecd22ebe6e54675},
				{a2e2fa9baf7d20822ca9f0542f764a41},
				{b6364ac4e1de1e285eaf144a2415f7a0},
				{64cf9c7abc50b888af65f49d521944b2},
				{47d6742eefcc0465dc96355e851b64d9},
				{3eb39790678c56bee34bbcdeccf6cdb5},
				{64110a924f0743d500ccadae72c13427},
				{18d8126516f8a12ab1a36d9f04d68e51},
				{da84367f325d42d601b4326964802e8e},
				{},
				{},
				{},
				{},
				{},
				{},
				{},
				{},
				{},
				{}
			};

			uint8_t ciphertext[20][16] = {
				{6d251e6944b051e04eaa6fb4dbf78465},
				{6e29201190152df4ee058139def610bb},
				{c3b44b95d9d2f25670eee9a0de099fa3},
				{5d9b05578fc944b3cf1ccf0e746cd581},
				{f7efc89d5dba578104016ce5ad659c05},
				{0306194f666d183624aa230a8b264ae7},
				{858075d536d79ccee571f7d7204b1f67},
				{35870c6a57e9e92314bcb8087cde72ce},
				{6c68e9be5ec41e22c825b7c7affb4363},
				{f530357968578480b398a3c251cd1093},
				{f5df39990fc688f1b07224cc03e86cea},
				{bba071bcb470f8f6586e5d3add18bc66},
				{},
				{},
				{},
				{},
				{},
				{},
				{},
				{}
			};

//				KEY = //				CIPHERTEXT = //
//				KEY = //				CIPHERTEXT = //
//				KEY = e37b1c6aa2846f6fdb413f238b089f23//				CIPHERTEXT = 43c9f7e62f5d288bb27aa40ef8fe1ea8//
//				KEY = 6c002b682483e0cabcc731c253be5674//				CIPHERTEXT = 3580d19cff44f1014a7c966a69059de5//
//				KEY = 143ae8ed6555aba96110ab58893a8ae1//				CIPHERTEXT = 806da864dd29d48deafbe764f8202aef//
//				KEY = b69418a85332240dc82492353956ae0c//				CIPHERTEXT = a303d940ded8f0baff6f75414cac5243//
//				KEY = 71b5c08a1993e1362e4d0ce9b22b78d5//				CIPHERTEXT = c2dabd117f8a3ecabfbb11d12194d9d0//
//				KEY = e234cdca2606b81f29408d5f6da21206//				CIPHERTEXT = fff60a4740086b3b9c56195b98d91a7b//
//				KEY = 13237c49074a3da078dc1d828bb78c6f//				CIPHERTEXT = 8146a08e2357f0caa30ca8c94d1a0544//
//				KEY = 3071a2a48fe6cbd04f1a129098e308f8//				CIPHERTEXT = 4b98e06d356deb07ebb824e5713f7be3//
//				KEY = 90f42ec0f68385f2ffc5dfc03a654dce//				CIPHERTEXT = 7a20a53d460fc9ce0423a7a0764c6cf2//
//				KEY = febd9a24d8b65c1c787d50a4ed3619a9//				CIPHERTEXT = f4a70d8af877f9b02b4c40df57d45b17

			

			auto failures = 0;
			for(auto i = 0; i < 6; i++)
			{
				char plaintext[16] = { 0 };
				auto IV = libcrypto::aes::make_block(plaintext, 0);
				auto k = libcrypto::aes::make_block(reinterpret_cast<char*>(key[i]), 0);
				
				auto result = libcrypto::aes::Encrypt(plaintext, 16, k, IV);
				if (result != 0)
				{
					std::cerr << "\t  Failure in CBC Encryption (Error code " << result << ")" << std::endl;
					failures++;
				}
				else
				{
					if(!blockEquals(reinterpret_cast<uint8_t*>(plaintext), ciphertext[i], 16))
					{
						std::cerr << "\t  Failure in CBC Decryption (Expected: ";
						printBlockToCERR(ciphertext[i]);
						std::cerr << " but got ";
						printBlockToCERR(reinterpret_cast<uint8_t*>(plaintext));
						std::cerr << ")" << std::endl;
						failures++;
					}
				}
			}

			return failures;
		}

		int CBCKeySBox128Decrypt()
		{
			return 0;
		}

		int Validate()
		{
			auto result = 0;

			result += ECBGFSBox128Encrypt();
			result += ECBGFSBox128Decrypt();
			result += CBCGFSBox128Encrypt();
			result += CBCGFSBox128Decrypt();
			result += CBCKeySBox128Encrypt();
			result += CBCKeySBox128Decrypt();

			return result;
		}
	}
}
